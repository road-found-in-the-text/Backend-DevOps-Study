# JPA의 필요성
객체와 관계형 데이터베이스의 차이?
객체에는 상속/캡슐화 등의 기능이 있다. 
Object를 저장하는 방법에 다양한 방법이 있다. 그 중 관계형 데이터베이스! RDB?
객체  ->  SQL 변환  ->  RDB 이렇게 SQL로 mapper하는 것이 우리의 역할이다!
sql을 삽입/조회/join .. 이 중간과정을 다 해야 한다.

java collection 에 저장한다고 가정해보자. 
list.add(album);
Album album = list.get(albumId);
그리고, 부모 타입으로 조회 후 다형성 활용도 가능하다.
Item item = list.get(albumId); 

연관관계가 있는 상태라면?
Team과 Member이 연관관계가 있는 상태라면, 자바 컬렉션으로 관리하면 그냥 해당 Team에 참조된 Member가 그대로 나오게 된다.

객체 그래프 탐색이 가능하면 좋다. 
SQL은 그래프 탐색에 불리하다. Member -- Order 
                             |--Team --Delivery 이렇게 되어있을 때 Order는 조회가 되는데 Delivery 조회는 안될 수 있다.
entity에 대한 신뢰 문제가 생긴다.
계층형 architecture? 다음 계층을 믿고 쓸 수 있어야 하는데, DAO를 까봐야 안다. 참조를 일일히 따라가기가 쉽지 않음
객체 vs 자바 컬렉션 **계층 분할** **객체 비교**

**객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까??**


# JPA - ORM
애플리케이션과 JDBC 사이에서 동작한다.
JPA 동작 - 저장 및 조회 : JPA야 회원 객체 저장해줘!

표준 명세
- JPA는 인터페이스의 모음이다.

# JPA 장점
- SQL 중심적인 개발에서 객체 중심으로 개발
- 생산성
- 유지보수
- 패러다임의 불일치 해결
- 성능
- 데이터 접근 추상화와 벤더 독립성
- 표준

# 방법
저장 : jpa.persist(member)
조회 : Member member = jpa.find(memberId)
수정 : member.setName("변경할 이름")
삭제 : jpa.remove(member)

# 유지보수
기존: 필드 변경 시 모든 SQL 수정
JPA: 필드만 추가하면 됨

# 패러다임의 불일치 해결
상속 관계 일 때 이미 join해줘서 반환해준다.
연관 관계 일 때, 참조 굳이 막 안해줘도 다 해줌

# 신뢰할 수 있는 엔티티, 계층

# 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장해줌

# JPA의 성능 최적화 기능
1. 1차 캐시와 동일성 보장
같은 트랜잭션 안에서는 같은 엔티티를 반환한다. 약간의 조회 성능을 향상시킴
2. 트랜잭션을 지원하는 쓰기 지연
INSERT
트랜잭션을 커밋할 때까지 INSERT SQL을 모음. 트랜잭션이 중요하기 때문에 그 전까지는 굳이 데이터베이스에 보내지 않는 것임!
3. 지연 로딩과 즉시로딩
지연로딩 - 객체가 실제 사용될 때 로딩되도록 하는 것! 
굳이 연관된 거(Member와 Team)가 같이 쓰이지도 않는데 가져올 필요가 없다.

# JPA 시작
EntityManagerFactory emf = Persistence.createEntityManagerFactory("hello");

EntityManager em = emf.createEntityManager();

em.close();

emf.close();

# 기타 정리
JPA에서는 트랜잭션이 아주 중요하다. 즉 JPA의 모든 데이터 변경은 트랜잭션 안에서 실행되어야 한다. EntityTransaction tx = em.getTransaction() 이걸 이해!

entity manager factory는 애플리케이션에서 하나만 생성하여 전체에서 공유하지만, entity manager는 쓰레드 간에 공유해서는 안 된다. 사용하고 버려야 한다.
Controller 파일이 다르다면, 새로운 Entity Manager를 생성하는 것이 좋을 것 같다.

# 영속성 컨텍스트 ==1차 캐시
엔티티를 영구 저장하는 환경
논리적인 개념이다. 눈에 보이지 않음

# 엔티티의 생명주기 persist
비영속 - 새로운 상태
영속 - 관리되는 상태
준영속 - 분리된 상태
em.detach(member);
삭제

그래서 영속성 컨텍스트 안에서 값을 찾는다면
처음에는 1차 캐시에서 찾고, 없으면 DB에서 찾아서 1차 캐시에 저장 후 가져오는 그런 형식임

영속 컨텍스트는 영속 엔티티의 동일성 또한 보장해준다.
==비교를 했을 때 1차 캐시에서 똑같은 것을 가져오기 떄문에 동일성이 보장됨

# 쓰기 지연
transaction.commit()을 하기 전까지는 DB에 저장하지 않는다.

# 